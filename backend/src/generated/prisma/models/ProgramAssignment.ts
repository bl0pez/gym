/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `ProgramAssignment` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model ProgramAssignment
 * 
 */
export type ProgramAssignmentModel = runtime.Types.Result.DefaultSelection<Prisma.$ProgramAssignmentPayload>

export type AggregateProgramAssignment = {
  _count: ProgramAssignmentCountAggregateOutputType | null
  _min: ProgramAssignmentMinAggregateOutputType | null
  _max: ProgramAssignmentMaxAggregateOutputType | null
}

export type ProgramAssignmentMinAggregateOutputType = {
  id: string | null
  userId: string | null
  programId: string | null
  isActive: boolean | null
  assignedAt: Date | null
}

export type ProgramAssignmentMaxAggregateOutputType = {
  id: string | null
  userId: string | null
  programId: string | null
  isActive: boolean | null
  assignedAt: Date | null
}

export type ProgramAssignmentCountAggregateOutputType = {
  id: number
  userId: number
  programId: number
  isActive: number
  assignedAt: number
  _all: number
}


export type ProgramAssignmentMinAggregateInputType = {
  id?: true
  userId?: true
  programId?: true
  isActive?: true
  assignedAt?: true
}

export type ProgramAssignmentMaxAggregateInputType = {
  id?: true
  userId?: true
  programId?: true
  isActive?: true
  assignedAt?: true
}

export type ProgramAssignmentCountAggregateInputType = {
  id?: true
  userId?: true
  programId?: true
  isActive?: true
  assignedAt?: true
  _all?: true
}

export type ProgramAssignmentAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ProgramAssignment to aggregate.
   */
  where?: Prisma.ProgramAssignmentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProgramAssignments to fetch.
   */
  orderBy?: Prisma.ProgramAssignmentOrderByWithRelationInput | Prisma.ProgramAssignmentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ProgramAssignmentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProgramAssignments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProgramAssignments.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned ProgramAssignments
  **/
  _count?: true | ProgramAssignmentCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ProgramAssignmentMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ProgramAssignmentMaxAggregateInputType
}

export type GetProgramAssignmentAggregateType<T extends ProgramAssignmentAggregateArgs> = {
      [P in keyof T & keyof AggregateProgramAssignment]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateProgramAssignment[P]>
    : Prisma.GetScalarType<T[P], AggregateProgramAssignment[P]>
}




export type ProgramAssignmentGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ProgramAssignmentWhereInput
  orderBy?: Prisma.ProgramAssignmentOrderByWithAggregationInput | Prisma.ProgramAssignmentOrderByWithAggregationInput[]
  by: Prisma.ProgramAssignmentScalarFieldEnum[] | Prisma.ProgramAssignmentScalarFieldEnum
  having?: Prisma.ProgramAssignmentScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ProgramAssignmentCountAggregateInputType | true
  _min?: ProgramAssignmentMinAggregateInputType
  _max?: ProgramAssignmentMaxAggregateInputType
}

export type ProgramAssignmentGroupByOutputType = {
  id: string
  userId: string
  programId: string
  isActive: boolean
  assignedAt: Date
  _count: ProgramAssignmentCountAggregateOutputType | null
  _min: ProgramAssignmentMinAggregateOutputType | null
  _max: ProgramAssignmentMaxAggregateOutputType | null
}

type GetProgramAssignmentGroupByPayload<T extends ProgramAssignmentGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ProgramAssignmentGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ProgramAssignmentGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ProgramAssignmentGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ProgramAssignmentGroupByOutputType[P]>
      }
    >
  >



export type ProgramAssignmentWhereInput = {
  AND?: Prisma.ProgramAssignmentWhereInput | Prisma.ProgramAssignmentWhereInput[]
  OR?: Prisma.ProgramAssignmentWhereInput[]
  NOT?: Prisma.ProgramAssignmentWhereInput | Prisma.ProgramAssignmentWhereInput[]
  id?: Prisma.StringFilter<"ProgramAssignment"> | string
  userId?: Prisma.StringFilter<"ProgramAssignment"> | string
  programId?: Prisma.StringFilter<"ProgramAssignment"> | string
  isActive?: Prisma.BoolFilter<"ProgramAssignment"> | boolean
  assignedAt?: Prisma.DateTimeFilter<"ProgramAssignment"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  program?: Prisma.XOR<Prisma.TrainingProgramScalarRelationFilter, Prisma.TrainingProgramWhereInput>
}

export type ProgramAssignmentOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  programId?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
  program?: Prisma.TrainingProgramOrderByWithRelationInput
}

export type ProgramAssignmentWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  userId_programId?: Prisma.ProgramAssignmentUserIdProgramIdCompoundUniqueInput
  AND?: Prisma.ProgramAssignmentWhereInput | Prisma.ProgramAssignmentWhereInput[]
  OR?: Prisma.ProgramAssignmentWhereInput[]
  NOT?: Prisma.ProgramAssignmentWhereInput | Prisma.ProgramAssignmentWhereInput[]
  userId?: Prisma.StringFilter<"ProgramAssignment"> | string
  programId?: Prisma.StringFilter<"ProgramAssignment"> | string
  isActive?: Prisma.BoolFilter<"ProgramAssignment"> | boolean
  assignedAt?: Prisma.DateTimeFilter<"ProgramAssignment"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  program?: Prisma.XOR<Prisma.TrainingProgramScalarRelationFilter, Prisma.TrainingProgramWhereInput>
}, "id" | "userId_programId">

export type ProgramAssignmentOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  programId?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
  _count?: Prisma.ProgramAssignmentCountOrderByAggregateInput
  _max?: Prisma.ProgramAssignmentMaxOrderByAggregateInput
  _min?: Prisma.ProgramAssignmentMinOrderByAggregateInput
}

export type ProgramAssignmentScalarWhereWithAggregatesInput = {
  AND?: Prisma.ProgramAssignmentScalarWhereWithAggregatesInput | Prisma.ProgramAssignmentScalarWhereWithAggregatesInput[]
  OR?: Prisma.ProgramAssignmentScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ProgramAssignmentScalarWhereWithAggregatesInput | Prisma.ProgramAssignmentScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"ProgramAssignment"> | string
  userId?: Prisma.StringWithAggregatesFilter<"ProgramAssignment"> | string
  programId?: Prisma.StringWithAggregatesFilter<"ProgramAssignment"> | string
  isActive?: Prisma.BoolWithAggregatesFilter<"ProgramAssignment"> | boolean
  assignedAt?: Prisma.DateTimeWithAggregatesFilter<"ProgramAssignment"> | Date | string
}

export type ProgramAssignmentCreateInput = {
  id?: string
  isActive?: boolean
  assignedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutAssignedProgramsInput
  program: Prisma.TrainingProgramCreateNestedOneWithoutAssignmentsInput
}

export type ProgramAssignmentUncheckedCreateInput = {
  id?: string
  userId: string
  programId: string
  isActive?: boolean
  assignedAt?: Date | string
}

export type ProgramAssignmentUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutAssignedProgramsNestedInput
  program?: Prisma.TrainingProgramUpdateOneRequiredWithoutAssignmentsNestedInput
}

export type ProgramAssignmentUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  programId?: Prisma.StringFieldUpdateOperationsInput | string
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProgramAssignmentCreateManyInput = {
  id?: string
  userId: string
  programId: string
  isActive?: boolean
  assignedAt?: Date | string
}

export type ProgramAssignmentUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProgramAssignmentUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  programId?: Prisma.StringFieldUpdateOperationsInput | string
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProgramAssignmentListRelationFilter = {
  every?: Prisma.ProgramAssignmentWhereInput
  some?: Prisma.ProgramAssignmentWhereInput
  none?: Prisma.ProgramAssignmentWhereInput
}

export type ProgramAssignmentOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ProgramAssignmentUserIdProgramIdCompoundUniqueInput = {
  userId: string
  programId: string
}

export type ProgramAssignmentCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  programId?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
}

export type ProgramAssignmentMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  programId?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
}

export type ProgramAssignmentMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  programId?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  assignedAt?: Prisma.SortOrder
}

export type ProgramAssignmentCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutUserInput, Prisma.ProgramAssignmentUncheckedCreateWithoutUserInput> | Prisma.ProgramAssignmentCreateWithoutUserInput[] | Prisma.ProgramAssignmentUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ProgramAssignmentCreateOrConnectWithoutUserInput | Prisma.ProgramAssignmentCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.ProgramAssignmentCreateManyUserInputEnvelope
  connect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
}

export type ProgramAssignmentUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutUserInput, Prisma.ProgramAssignmentUncheckedCreateWithoutUserInput> | Prisma.ProgramAssignmentCreateWithoutUserInput[] | Prisma.ProgramAssignmentUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ProgramAssignmentCreateOrConnectWithoutUserInput | Prisma.ProgramAssignmentCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.ProgramAssignmentCreateManyUserInputEnvelope
  connect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
}

export type ProgramAssignmentUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutUserInput, Prisma.ProgramAssignmentUncheckedCreateWithoutUserInput> | Prisma.ProgramAssignmentCreateWithoutUserInput[] | Prisma.ProgramAssignmentUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ProgramAssignmentCreateOrConnectWithoutUserInput | Prisma.ProgramAssignmentCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.ProgramAssignmentUpsertWithWhereUniqueWithoutUserInput | Prisma.ProgramAssignmentUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.ProgramAssignmentCreateManyUserInputEnvelope
  set?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  disconnect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  delete?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  connect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  update?: Prisma.ProgramAssignmentUpdateWithWhereUniqueWithoutUserInput | Prisma.ProgramAssignmentUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.ProgramAssignmentUpdateManyWithWhereWithoutUserInput | Prisma.ProgramAssignmentUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.ProgramAssignmentScalarWhereInput | Prisma.ProgramAssignmentScalarWhereInput[]
}

export type ProgramAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutUserInput, Prisma.ProgramAssignmentUncheckedCreateWithoutUserInput> | Prisma.ProgramAssignmentCreateWithoutUserInput[] | Prisma.ProgramAssignmentUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.ProgramAssignmentCreateOrConnectWithoutUserInput | Prisma.ProgramAssignmentCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.ProgramAssignmentUpsertWithWhereUniqueWithoutUserInput | Prisma.ProgramAssignmentUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.ProgramAssignmentCreateManyUserInputEnvelope
  set?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  disconnect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  delete?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  connect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  update?: Prisma.ProgramAssignmentUpdateWithWhereUniqueWithoutUserInput | Prisma.ProgramAssignmentUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.ProgramAssignmentUpdateManyWithWhereWithoutUserInput | Prisma.ProgramAssignmentUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.ProgramAssignmentScalarWhereInput | Prisma.ProgramAssignmentScalarWhereInput[]
}

export type ProgramAssignmentCreateNestedManyWithoutProgramInput = {
  create?: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutProgramInput, Prisma.ProgramAssignmentUncheckedCreateWithoutProgramInput> | Prisma.ProgramAssignmentCreateWithoutProgramInput[] | Prisma.ProgramAssignmentUncheckedCreateWithoutProgramInput[]
  connectOrCreate?: Prisma.ProgramAssignmentCreateOrConnectWithoutProgramInput | Prisma.ProgramAssignmentCreateOrConnectWithoutProgramInput[]
  createMany?: Prisma.ProgramAssignmentCreateManyProgramInputEnvelope
  connect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
}

export type ProgramAssignmentUncheckedCreateNestedManyWithoutProgramInput = {
  create?: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutProgramInput, Prisma.ProgramAssignmentUncheckedCreateWithoutProgramInput> | Prisma.ProgramAssignmentCreateWithoutProgramInput[] | Prisma.ProgramAssignmentUncheckedCreateWithoutProgramInput[]
  connectOrCreate?: Prisma.ProgramAssignmentCreateOrConnectWithoutProgramInput | Prisma.ProgramAssignmentCreateOrConnectWithoutProgramInput[]
  createMany?: Prisma.ProgramAssignmentCreateManyProgramInputEnvelope
  connect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
}

export type ProgramAssignmentUpdateManyWithoutProgramNestedInput = {
  create?: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutProgramInput, Prisma.ProgramAssignmentUncheckedCreateWithoutProgramInput> | Prisma.ProgramAssignmentCreateWithoutProgramInput[] | Prisma.ProgramAssignmentUncheckedCreateWithoutProgramInput[]
  connectOrCreate?: Prisma.ProgramAssignmentCreateOrConnectWithoutProgramInput | Prisma.ProgramAssignmentCreateOrConnectWithoutProgramInput[]
  upsert?: Prisma.ProgramAssignmentUpsertWithWhereUniqueWithoutProgramInput | Prisma.ProgramAssignmentUpsertWithWhereUniqueWithoutProgramInput[]
  createMany?: Prisma.ProgramAssignmentCreateManyProgramInputEnvelope
  set?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  disconnect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  delete?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  connect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  update?: Prisma.ProgramAssignmentUpdateWithWhereUniqueWithoutProgramInput | Prisma.ProgramAssignmentUpdateWithWhereUniqueWithoutProgramInput[]
  updateMany?: Prisma.ProgramAssignmentUpdateManyWithWhereWithoutProgramInput | Prisma.ProgramAssignmentUpdateManyWithWhereWithoutProgramInput[]
  deleteMany?: Prisma.ProgramAssignmentScalarWhereInput | Prisma.ProgramAssignmentScalarWhereInput[]
}

export type ProgramAssignmentUncheckedUpdateManyWithoutProgramNestedInput = {
  create?: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutProgramInput, Prisma.ProgramAssignmentUncheckedCreateWithoutProgramInput> | Prisma.ProgramAssignmentCreateWithoutProgramInput[] | Prisma.ProgramAssignmentUncheckedCreateWithoutProgramInput[]
  connectOrCreate?: Prisma.ProgramAssignmentCreateOrConnectWithoutProgramInput | Prisma.ProgramAssignmentCreateOrConnectWithoutProgramInput[]
  upsert?: Prisma.ProgramAssignmentUpsertWithWhereUniqueWithoutProgramInput | Prisma.ProgramAssignmentUpsertWithWhereUniqueWithoutProgramInput[]
  createMany?: Prisma.ProgramAssignmentCreateManyProgramInputEnvelope
  set?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  disconnect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  delete?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  connect?: Prisma.ProgramAssignmentWhereUniqueInput | Prisma.ProgramAssignmentWhereUniqueInput[]
  update?: Prisma.ProgramAssignmentUpdateWithWhereUniqueWithoutProgramInput | Prisma.ProgramAssignmentUpdateWithWhereUniqueWithoutProgramInput[]
  updateMany?: Prisma.ProgramAssignmentUpdateManyWithWhereWithoutProgramInput | Prisma.ProgramAssignmentUpdateManyWithWhereWithoutProgramInput[]
  deleteMany?: Prisma.ProgramAssignmentScalarWhereInput | Prisma.ProgramAssignmentScalarWhereInput[]
}

export type ProgramAssignmentCreateWithoutUserInput = {
  id?: string
  isActive?: boolean
  assignedAt?: Date | string
  program: Prisma.TrainingProgramCreateNestedOneWithoutAssignmentsInput
}

export type ProgramAssignmentUncheckedCreateWithoutUserInput = {
  id?: string
  programId: string
  isActive?: boolean
  assignedAt?: Date | string
}

export type ProgramAssignmentCreateOrConnectWithoutUserInput = {
  where: Prisma.ProgramAssignmentWhereUniqueInput
  create: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutUserInput, Prisma.ProgramAssignmentUncheckedCreateWithoutUserInput>
}

export type ProgramAssignmentCreateManyUserInputEnvelope = {
  data: Prisma.ProgramAssignmentCreateManyUserInput | Prisma.ProgramAssignmentCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type ProgramAssignmentUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.ProgramAssignmentWhereUniqueInput
  update: Prisma.XOR<Prisma.ProgramAssignmentUpdateWithoutUserInput, Prisma.ProgramAssignmentUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutUserInput, Prisma.ProgramAssignmentUncheckedCreateWithoutUserInput>
}

export type ProgramAssignmentUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.ProgramAssignmentWhereUniqueInput
  data: Prisma.XOR<Prisma.ProgramAssignmentUpdateWithoutUserInput, Prisma.ProgramAssignmentUncheckedUpdateWithoutUserInput>
}

export type ProgramAssignmentUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.ProgramAssignmentScalarWhereInput
  data: Prisma.XOR<Prisma.ProgramAssignmentUpdateManyMutationInput, Prisma.ProgramAssignmentUncheckedUpdateManyWithoutUserInput>
}

export type ProgramAssignmentScalarWhereInput = {
  AND?: Prisma.ProgramAssignmentScalarWhereInput | Prisma.ProgramAssignmentScalarWhereInput[]
  OR?: Prisma.ProgramAssignmentScalarWhereInput[]
  NOT?: Prisma.ProgramAssignmentScalarWhereInput | Prisma.ProgramAssignmentScalarWhereInput[]
  id?: Prisma.StringFilter<"ProgramAssignment"> | string
  userId?: Prisma.StringFilter<"ProgramAssignment"> | string
  programId?: Prisma.StringFilter<"ProgramAssignment"> | string
  isActive?: Prisma.BoolFilter<"ProgramAssignment"> | boolean
  assignedAt?: Prisma.DateTimeFilter<"ProgramAssignment"> | Date | string
}

export type ProgramAssignmentCreateWithoutProgramInput = {
  id?: string
  isActive?: boolean
  assignedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutAssignedProgramsInput
}

export type ProgramAssignmentUncheckedCreateWithoutProgramInput = {
  id?: string
  userId: string
  isActive?: boolean
  assignedAt?: Date | string
}

export type ProgramAssignmentCreateOrConnectWithoutProgramInput = {
  where: Prisma.ProgramAssignmentWhereUniqueInput
  create: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutProgramInput, Prisma.ProgramAssignmentUncheckedCreateWithoutProgramInput>
}

export type ProgramAssignmentCreateManyProgramInputEnvelope = {
  data: Prisma.ProgramAssignmentCreateManyProgramInput | Prisma.ProgramAssignmentCreateManyProgramInput[]
  skipDuplicates?: boolean
}

export type ProgramAssignmentUpsertWithWhereUniqueWithoutProgramInput = {
  where: Prisma.ProgramAssignmentWhereUniqueInput
  update: Prisma.XOR<Prisma.ProgramAssignmentUpdateWithoutProgramInput, Prisma.ProgramAssignmentUncheckedUpdateWithoutProgramInput>
  create: Prisma.XOR<Prisma.ProgramAssignmentCreateWithoutProgramInput, Prisma.ProgramAssignmentUncheckedCreateWithoutProgramInput>
}

export type ProgramAssignmentUpdateWithWhereUniqueWithoutProgramInput = {
  where: Prisma.ProgramAssignmentWhereUniqueInput
  data: Prisma.XOR<Prisma.ProgramAssignmentUpdateWithoutProgramInput, Prisma.ProgramAssignmentUncheckedUpdateWithoutProgramInput>
}

export type ProgramAssignmentUpdateManyWithWhereWithoutProgramInput = {
  where: Prisma.ProgramAssignmentScalarWhereInput
  data: Prisma.XOR<Prisma.ProgramAssignmentUpdateManyMutationInput, Prisma.ProgramAssignmentUncheckedUpdateManyWithoutProgramInput>
}

export type ProgramAssignmentCreateManyUserInput = {
  id?: string
  programId: string
  isActive?: boolean
  assignedAt?: Date | string
}

export type ProgramAssignmentUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  program?: Prisma.TrainingProgramUpdateOneRequiredWithoutAssignmentsNestedInput
}

export type ProgramAssignmentUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  programId?: Prisma.StringFieldUpdateOperationsInput | string
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProgramAssignmentUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  programId?: Prisma.StringFieldUpdateOperationsInput | string
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProgramAssignmentCreateManyProgramInput = {
  id?: string
  userId: string
  isActive?: boolean
  assignedAt?: Date | string
}

export type ProgramAssignmentUpdateWithoutProgramInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutAssignedProgramsNestedInput
}

export type ProgramAssignmentUncheckedUpdateWithoutProgramInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type ProgramAssignmentUncheckedUpdateManyWithoutProgramInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  assignedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type ProgramAssignmentSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  programId?: boolean
  isActive?: boolean
  assignedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  program?: boolean | Prisma.TrainingProgramDefaultArgs<ExtArgs>
}, ExtArgs["result"]["programAssignment"]>

export type ProgramAssignmentSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  programId?: boolean
  isActive?: boolean
  assignedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  program?: boolean | Prisma.TrainingProgramDefaultArgs<ExtArgs>
}, ExtArgs["result"]["programAssignment"]>

export type ProgramAssignmentSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  programId?: boolean
  isActive?: boolean
  assignedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  program?: boolean | Prisma.TrainingProgramDefaultArgs<ExtArgs>
}, ExtArgs["result"]["programAssignment"]>

export type ProgramAssignmentSelectScalar = {
  id?: boolean
  userId?: boolean
  programId?: boolean
  isActive?: boolean
  assignedAt?: boolean
}

export type ProgramAssignmentOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "programId" | "isActive" | "assignedAt", ExtArgs["result"]["programAssignment"]>
export type ProgramAssignmentInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  program?: boolean | Prisma.TrainingProgramDefaultArgs<ExtArgs>
}
export type ProgramAssignmentIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  program?: boolean | Prisma.TrainingProgramDefaultArgs<ExtArgs>
}
export type ProgramAssignmentIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  program?: boolean | Prisma.TrainingProgramDefaultArgs<ExtArgs>
}

export type $ProgramAssignmentPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "ProgramAssignment"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
    program: Prisma.$TrainingProgramPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    userId: string
    programId: string
    isActive: boolean
    assignedAt: Date
  }, ExtArgs["result"]["programAssignment"]>
  composites: {}
}

export type ProgramAssignmentGetPayload<S extends boolean | null | undefined | ProgramAssignmentDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload, S>

export type ProgramAssignmentCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ProgramAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ProgramAssignmentCountAggregateInputType | true
  }

export interface ProgramAssignmentDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramAssignment'], meta: { name: 'ProgramAssignment' } }
  /**
   * Find zero or one ProgramAssignment that matches the filter.
   * @param {ProgramAssignmentFindUniqueArgs} args - Arguments to find a ProgramAssignment
   * @example
   * // Get one ProgramAssignment
   * const programAssignment = await prisma.programAssignment.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ProgramAssignmentFindUniqueArgs>(args: Prisma.SelectSubset<T, ProgramAssignmentFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ProgramAssignmentClient<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one ProgramAssignment that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ProgramAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ProgramAssignment
   * @example
   * // Get one ProgramAssignment
   * const programAssignment = await prisma.programAssignment.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ProgramAssignmentFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ProgramAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProgramAssignmentClient<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ProgramAssignment that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProgramAssignmentFindFirstArgs} args - Arguments to find a ProgramAssignment
   * @example
   * // Get one ProgramAssignment
   * const programAssignment = await prisma.programAssignment.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ProgramAssignmentFindFirstArgs>(args?: Prisma.SelectSubset<T, ProgramAssignmentFindFirstArgs<ExtArgs>>): Prisma.Prisma__ProgramAssignmentClient<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ProgramAssignment that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProgramAssignmentFindFirstOrThrowArgs} args - Arguments to find a ProgramAssignment
   * @example
   * // Get one ProgramAssignment
   * const programAssignment = await prisma.programAssignment.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ProgramAssignmentFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ProgramAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ProgramAssignmentClient<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more ProgramAssignments that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProgramAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ProgramAssignments
   * const programAssignments = await prisma.programAssignment.findMany()
   * 
   * // Get first 10 ProgramAssignments
   * const programAssignments = await prisma.programAssignment.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const programAssignmentWithIdOnly = await prisma.programAssignment.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends ProgramAssignmentFindManyArgs>(args?: Prisma.SelectSubset<T, ProgramAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a ProgramAssignment.
   * @param {ProgramAssignmentCreateArgs} args - Arguments to create a ProgramAssignment.
   * @example
   * // Create one ProgramAssignment
   * const ProgramAssignment = await prisma.programAssignment.create({
   *   data: {
   *     // ... data to create a ProgramAssignment
   *   }
   * })
   * 
   */
  create<T extends ProgramAssignmentCreateArgs>(args: Prisma.SelectSubset<T, ProgramAssignmentCreateArgs<ExtArgs>>): Prisma.Prisma__ProgramAssignmentClient<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many ProgramAssignments.
   * @param {ProgramAssignmentCreateManyArgs} args - Arguments to create many ProgramAssignments.
   * @example
   * // Create many ProgramAssignments
   * const programAssignment = await prisma.programAssignment.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ProgramAssignmentCreateManyArgs>(args?: Prisma.SelectSubset<T, ProgramAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ProgramAssignments and returns the data saved in the database.
   * @param {ProgramAssignmentCreateManyAndReturnArgs} args - Arguments to create many ProgramAssignments.
   * @example
   * // Create many ProgramAssignments
   * const programAssignment = await prisma.programAssignment.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many ProgramAssignments and only return the `id`
   * const programAssignmentWithIdOnly = await prisma.programAssignment.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ProgramAssignmentCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ProgramAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a ProgramAssignment.
   * @param {ProgramAssignmentDeleteArgs} args - Arguments to delete one ProgramAssignment.
   * @example
   * // Delete one ProgramAssignment
   * const ProgramAssignment = await prisma.programAssignment.delete({
   *   where: {
   *     // ... filter to delete one ProgramAssignment
   *   }
   * })
   * 
   */
  delete<T extends ProgramAssignmentDeleteArgs>(args: Prisma.SelectSubset<T, ProgramAssignmentDeleteArgs<ExtArgs>>): Prisma.Prisma__ProgramAssignmentClient<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one ProgramAssignment.
   * @param {ProgramAssignmentUpdateArgs} args - Arguments to update one ProgramAssignment.
   * @example
   * // Update one ProgramAssignment
   * const programAssignment = await prisma.programAssignment.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ProgramAssignmentUpdateArgs>(args: Prisma.SelectSubset<T, ProgramAssignmentUpdateArgs<ExtArgs>>): Prisma.Prisma__ProgramAssignmentClient<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more ProgramAssignments.
   * @param {ProgramAssignmentDeleteManyArgs} args - Arguments to filter ProgramAssignments to delete.
   * @example
   * // Delete a few ProgramAssignments
   * const { count } = await prisma.programAssignment.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ProgramAssignmentDeleteManyArgs>(args?: Prisma.SelectSubset<T, ProgramAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ProgramAssignments.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProgramAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ProgramAssignments
   * const programAssignment = await prisma.programAssignment.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ProgramAssignmentUpdateManyArgs>(args: Prisma.SelectSubset<T, ProgramAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ProgramAssignments and returns the data updated in the database.
   * @param {ProgramAssignmentUpdateManyAndReturnArgs} args - Arguments to update many ProgramAssignments.
   * @example
   * // Update many ProgramAssignments
   * const programAssignment = await prisma.programAssignment.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more ProgramAssignments and only return the `id`
   * const programAssignmentWithIdOnly = await prisma.programAssignment.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ProgramAssignmentUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ProgramAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one ProgramAssignment.
   * @param {ProgramAssignmentUpsertArgs} args - Arguments to update or create a ProgramAssignment.
   * @example
   * // Update or create a ProgramAssignment
   * const programAssignment = await prisma.programAssignment.upsert({
   *   create: {
   *     // ... data to create a ProgramAssignment
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ProgramAssignment we want to update
   *   }
   * })
   */
  upsert<T extends ProgramAssignmentUpsertArgs>(args: Prisma.SelectSubset<T, ProgramAssignmentUpsertArgs<ExtArgs>>): Prisma.Prisma__ProgramAssignmentClient<runtime.Types.Result.GetResult<Prisma.$ProgramAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of ProgramAssignments.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProgramAssignmentCountArgs} args - Arguments to filter ProgramAssignments to count.
   * @example
   * // Count the number of ProgramAssignments
   * const count = await prisma.programAssignment.count({
   *   where: {
   *     // ... the filter for the ProgramAssignments we want to count
   *   }
   * })
  **/
  count<T extends ProgramAssignmentCountArgs>(
    args?: Prisma.Subset<T, ProgramAssignmentCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ProgramAssignmentCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ProgramAssignment.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProgramAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ProgramAssignmentAggregateArgs>(args: Prisma.Subset<T, ProgramAssignmentAggregateArgs>): Prisma.PrismaPromise<GetProgramAssignmentAggregateType<T>>

  /**
   * Group by ProgramAssignment.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ProgramAssignmentGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ProgramAssignmentGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ProgramAssignmentGroupByArgs['orderBy'] }
      : { orderBy?: ProgramAssignmentGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ProgramAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the ProgramAssignment model
 */
readonly fields: ProgramAssignmentFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ProgramAssignment.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ProgramAssignmentClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  program<T extends Prisma.TrainingProgramDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TrainingProgramDefaultArgs<ExtArgs>>): Prisma.Prisma__TrainingProgramClient<runtime.Types.Result.GetResult<Prisma.$TrainingProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the ProgramAssignment model
 */
export interface ProgramAssignmentFieldRefs {
  readonly id: Prisma.FieldRef<"ProgramAssignment", 'String'>
  readonly userId: Prisma.FieldRef<"ProgramAssignment", 'String'>
  readonly programId: Prisma.FieldRef<"ProgramAssignment", 'String'>
  readonly isActive: Prisma.FieldRef<"ProgramAssignment", 'Boolean'>
  readonly assignedAt: Prisma.FieldRef<"ProgramAssignment", 'DateTime'>
}
    

// Custom InputTypes
/**
 * ProgramAssignment findUnique
 */
export type ProgramAssignmentFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentInclude<ExtArgs> | null
  /**
   * Filter, which ProgramAssignment to fetch.
   */
  where: Prisma.ProgramAssignmentWhereUniqueInput
}

/**
 * ProgramAssignment findUniqueOrThrow
 */
export type ProgramAssignmentFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentInclude<ExtArgs> | null
  /**
   * Filter, which ProgramAssignment to fetch.
   */
  where: Prisma.ProgramAssignmentWhereUniqueInput
}

/**
 * ProgramAssignment findFirst
 */
export type ProgramAssignmentFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentInclude<ExtArgs> | null
  /**
   * Filter, which ProgramAssignment to fetch.
   */
  where?: Prisma.ProgramAssignmentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProgramAssignments to fetch.
   */
  orderBy?: Prisma.ProgramAssignmentOrderByWithRelationInput | Prisma.ProgramAssignmentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ProgramAssignments.
   */
  cursor?: Prisma.ProgramAssignmentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProgramAssignments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProgramAssignments.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ProgramAssignments.
   */
  distinct?: Prisma.ProgramAssignmentScalarFieldEnum | Prisma.ProgramAssignmentScalarFieldEnum[]
}

/**
 * ProgramAssignment findFirstOrThrow
 */
export type ProgramAssignmentFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentInclude<ExtArgs> | null
  /**
   * Filter, which ProgramAssignment to fetch.
   */
  where?: Prisma.ProgramAssignmentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProgramAssignments to fetch.
   */
  orderBy?: Prisma.ProgramAssignmentOrderByWithRelationInput | Prisma.ProgramAssignmentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ProgramAssignments.
   */
  cursor?: Prisma.ProgramAssignmentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProgramAssignments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProgramAssignments.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ProgramAssignments.
   */
  distinct?: Prisma.ProgramAssignmentScalarFieldEnum | Prisma.ProgramAssignmentScalarFieldEnum[]
}

/**
 * ProgramAssignment findMany
 */
export type ProgramAssignmentFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentInclude<ExtArgs> | null
  /**
   * Filter, which ProgramAssignments to fetch.
   */
  where?: Prisma.ProgramAssignmentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ProgramAssignments to fetch.
   */
  orderBy?: Prisma.ProgramAssignmentOrderByWithRelationInput | Prisma.ProgramAssignmentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing ProgramAssignments.
   */
  cursor?: Prisma.ProgramAssignmentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ProgramAssignments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ProgramAssignments.
   */
  skip?: number
  distinct?: Prisma.ProgramAssignmentScalarFieldEnum | Prisma.ProgramAssignmentScalarFieldEnum[]
}

/**
 * ProgramAssignment create
 */
export type ProgramAssignmentCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentInclude<ExtArgs> | null
  /**
   * The data needed to create a ProgramAssignment.
   */
  data: Prisma.XOR<Prisma.ProgramAssignmentCreateInput, Prisma.ProgramAssignmentUncheckedCreateInput>
}

/**
 * ProgramAssignment createMany
 */
export type ProgramAssignmentCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many ProgramAssignments.
   */
  data: Prisma.ProgramAssignmentCreateManyInput | Prisma.ProgramAssignmentCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * ProgramAssignment createManyAndReturn
 */
export type ProgramAssignmentCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * The data used to create many ProgramAssignments.
   */
  data: Prisma.ProgramAssignmentCreateManyInput | Prisma.ProgramAssignmentCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * ProgramAssignment update
 */
export type ProgramAssignmentUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentInclude<ExtArgs> | null
  /**
   * The data needed to update a ProgramAssignment.
   */
  data: Prisma.XOR<Prisma.ProgramAssignmentUpdateInput, Prisma.ProgramAssignmentUncheckedUpdateInput>
  /**
   * Choose, which ProgramAssignment to update.
   */
  where: Prisma.ProgramAssignmentWhereUniqueInput
}

/**
 * ProgramAssignment updateMany
 */
export type ProgramAssignmentUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update ProgramAssignments.
   */
  data: Prisma.XOR<Prisma.ProgramAssignmentUpdateManyMutationInput, Prisma.ProgramAssignmentUncheckedUpdateManyInput>
  /**
   * Filter which ProgramAssignments to update
   */
  where?: Prisma.ProgramAssignmentWhereInput
  /**
   * Limit how many ProgramAssignments to update.
   */
  limit?: number
}

/**
 * ProgramAssignment updateManyAndReturn
 */
export type ProgramAssignmentUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * The data used to update ProgramAssignments.
   */
  data: Prisma.XOR<Prisma.ProgramAssignmentUpdateManyMutationInput, Prisma.ProgramAssignmentUncheckedUpdateManyInput>
  /**
   * Filter which ProgramAssignments to update
   */
  where?: Prisma.ProgramAssignmentWhereInput
  /**
   * Limit how many ProgramAssignments to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * ProgramAssignment upsert
 */
export type ProgramAssignmentUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentInclude<ExtArgs> | null
  /**
   * The filter to search for the ProgramAssignment to update in case it exists.
   */
  where: Prisma.ProgramAssignmentWhereUniqueInput
  /**
   * In case the ProgramAssignment found by the `where` argument doesn't exist, create a new ProgramAssignment with this data.
   */
  create: Prisma.XOR<Prisma.ProgramAssignmentCreateInput, Prisma.ProgramAssignmentUncheckedCreateInput>
  /**
   * In case the ProgramAssignment was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ProgramAssignmentUpdateInput, Prisma.ProgramAssignmentUncheckedUpdateInput>
}

/**
 * ProgramAssignment delete
 */
export type ProgramAssignmentDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentInclude<ExtArgs> | null
  /**
   * Filter which ProgramAssignment to delete.
   */
  where: Prisma.ProgramAssignmentWhereUniqueInput
}

/**
 * ProgramAssignment deleteMany
 */
export type ProgramAssignmentDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ProgramAssignments to delete
   */
  where?: Prisma.ProgramAssignmentWhereInput
  /**
   * Limit how many ProgramAssignments to delete.
   */
  limit?: number
}

/**
 * ProgramAssignment without action
 */
export type ProgramAssignmentDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ProgramAssignment
   */
  select?: Prisma.ProgramAssignmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ProgramAssignment
   */
  omit?: Prisma.ProgramAssignmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ProgramAssignmentInclude<ExtArgs> | null
}
